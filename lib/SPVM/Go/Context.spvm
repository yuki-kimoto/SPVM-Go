# Copyright (c) 2026 Yuki Kimoto
# MIT License

class Go::Context {
  version_from Go;
  
  use Go::Channel;
  use Go::Time;
  use Go::Context::Derived;
  use Go::Context::Value;
  use Go::Context::Error::Canceled;
  use Go::Context::Error::DeadlineExceeded;
  
  use Fn;
  
  # Fields
  has deadline : ro Go::Time;
  
  has done : ro Go::Channel;
  
  has err : ro int;
  
  has cause : ro string;
  
  has key : object;
  
  has value : object;
  
  has parent : Go::Context;
  
  has children : Go::Context[];
  
  # Class Methods
  static method with_background : Go::Context () {
    
    my $self = new Go::Context;
    
    $self->init;
    
    return $self;
  }
  
  static method without_cancel : Go::Context ($ctx : Go::Context) {
    
    unless ($ctx) {
      die "Go::Context \$ctx must be defined.";
    }
    
    my $self = new Go::Context;
    
    $self->init;
    
    $self->{parent} = $ctx;
    
    return $self;
  }
  
  static method with_cancel : Go::Context::Derived ($ctx : Go::Context) {
    
    return &with_cancel_common($ctx, basic_type_id Go::Context::Error::Canceled, undef, undef);
  }
  
  static method with_cancel_cause : Go::Context::Derived ($ctx : Go::Context, $cause : string) {
    
    return &with_cancel_common($ctx, basic_type_id Go::Context::Error::Canceled, $cause, undef);
  }
  
  static method with_deadline : Go::Context::Derived ($ctx : Go::Context, $deadline : Go::Time) {
    
    return &with_cancel_common($ctx, basic_type_id Go::Context::Error::DeadlineExceeded, undef, $deadline);
  }
  
  static method with_deadline_cause : Go::Context::Derived ($ctx : Go::Context, $deadline : Go::Time, $cause : string) {
    
    return &with_cancel_common($ctx, basic_type_id Go::Context::Error::DeadlineExceeded, $cause, $deadline);
  }
  
  static method with_timeout : Go::Context::Derived ($ctx : Go::Context, $timeout : Go::Duration_1l) {
    
    return &with_deadline($ctx, Go::Time->now->add($timeout));
  }
  
  static method with_timeout_sec : Go::Context::Derived ($ctx : Go::Context, $timeout_sec : double) {
    
    my $timeout = Go::Duration_1l->new_from_sec($timeout_sec);
    
    return &with_timeout($ctx, $timeout);
  }
  
  static method new_with_value : Go::Context ($ctx : Go::Context, $key : object, $value : object) {
    return Go::Context::Value->new_with_value($ctx, $key, $value);
  }
  
  private static method with_cancel_common : Go::Context::Derived ($ctx : Go::Context, $err : int = 0, $cause : string = undef, $deadline : Go::Time = undef) {
    
    unless ($ctx) {
      die "Go::Context \$ctx must be defined.";
    }
    
    unless ($err > 0) {
      die "[Unexpected Error]\$err must be a positive value.";
    }
    
    unless ($cause) {
      if ($err == basic_type_id Go::Context::Error::Canceled) {
        $cause = "context canceled";
      }
      elsif ($err == basic_type_id Go::Context::Error::DeadlineExceeded) {
        $cause = "context deadline exceeded";
      }
    }
    
    my $self = new Go::Context;
    
    $self->init;
    
    $self->{parent} = $ctx;
    List->new_ref($ctx->{children})->push($ctx);
    weaken $self->{parent};
    
    $self->{done} = Go->make;
    
    my $cancel = [$err : int, $cause : string, $ctx : Go::Context] method : void ($cause : string) {
      
      if ($ctx->err > 0) {
        return;
      }
      
      $ctx->{err} = $err;
      $ctx->{cause} = $cause;
      
      my $children = (List of Go::Context)List->new_ref($ctx->{children});
      
      while (my $child = $children->shift) {
        
        unweaken $child->{parent};
        
        unless ($child isa Go::Context::Value) {
          if ($child->done) {
            $child->done->close;
            $child->{err} = $err;
            $child->{cause} = $cause;
          }
        }
        
        $children->push_($child->{children});
      }
      
    };
    
    my $derived = my $_ = Go::Context::Derived->new;
    $_->set_ctx($self);
    $_->set_cancel($cancel);
    
    if ($deadline) {
      
      if ($self->{parent} && $self->{parent}{deadline}) {
        if ($deadline->after($self->{parent}{deadline})) {
          $deadline = $self->{parent}{deadline}->clone;
        }
      }
      
      $self->{deadline} = $deadline;
      
      Go->go([$ctx : Go::Context = $self, $deadline : Go::Time, $cancel : Go::Context::CancelCallback, $cause : string] method : void () {
        
        my $timeout_duration = $deadline->sub(Go::Time->now);
        my $sleep_sec = Go::Duration_1l->to_sec($timeout_duration);
        
        Go->sleep($sleep_sec);
        
        $cancel->($cause);
      });
    }
    
  }
  
  # Instance Methods
  protected method init : void () {
    
    $self->{children} = new Go::Context[0];
  }
  
  method value : object ($key : object) {
    
    unless ($key) {
      die "The key \$key must be defined";
    }
    
    my $value = (object)undef;
    if ($self->{key} && Fn->to_address($key) eq Fn->to_address($self->{key})) {
      $value = $self->{value};
    }
    else {
      if ($self->{parent}) {
        $value = $self->{parent}->value($key);
      }
    }
    
    return $value;
  }
  
}
