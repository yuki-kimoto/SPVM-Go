# Copyright (c) 2026 Yuki Kimoto
# MIT License

class Go::Time {
  version_from Go;
  
  use Sys::Time::Timespec;
  use Sys::Time::Constant as TIME;
  use Go::Duration_1l;
  
  # Interfaces
  interface Cloneable;
  
  # Fields
  has real_sec : long;
  
  has real_nsec : long;
  
  has has_monotonic_time : ro byte;
  
  has mono_timespec : Sys::Time::Timespec;
  
  # Class Methods
  static method NANOSECOND  : long () { return 1L; }
  
  static method MICROSECOND : long () { return 1_000L; }
  
  static method MILLISECOND : long () { return 1_000_000L; }
  
  static method SECOND      : long () { return 1_000_000_000L; }
  
  static method MINUTE      : long () { return 60_000_000_000L; }
  
  static method HOUR        : long () { return 3_600_000_000_000L; }
  
  static method unix : Go::Time ($sec : long, $nsec : long = 0) {
    
    my $self = new Go::Time;
    
    my $real_timespec = Sys::Time::Timespec->new;
    
    $real_timespec->set_tv_sec($sec);
    $real_timespec->set_tv_nsec($nsec);
    
    return $self;
  }
  
  static method now : Go::Time () {
    
    my $self = new Go::Time;
    
    my $real_timespec = Time::HiRes->clock_gettime_timespec(TIME->CLOCK_REALTIME);
    
    $self->{real_sec} = $real_timespec->tv_sec;
    $self->{real_nsec} = $real_timespec->tv_nsec;
    
    $self->{mono_timespec} = Time::HiRes->clock_gettime_timespec(TIME->CLOCK_MONOTONIC);;
    
    return $self;
  }
  
  # Instance Methods
  method add : Go::Time ($duration_nsec : Go::Duration_1l) {
    
    my $nsec = $duration_nsec->{nsec};
    
    my $clone = $self->clone;
    
    my $nsec_to_timespec = Sys::Time::Util->nanoseconds_to_timespec($nsec);
    
    my $real_timespec = Sys::Time::Util->add_timespec($self->real_timespec, $nsec_to_timespec);
    $clone->{real_sec} = $real_timespec->tv_sec;
    $clone->{real_nsec} = $real_timespec->tv_nsec;
    
    if ($self->{mono_timespec}) {
      $clone->{mono_timespec} = Sys::Time::Util->add_timespec($self->{mono_timespec}, $nsec_to_timespec);
    }
    
    return $clone;
  }
  
  method add_sec : Go::Time ($seconds : double) {
    
    my $nsec = Sys::Time::Util->float_seconds_to_nanoseconds($seconds);
    
    my $duration_nsec = Go::Duration_1l->new($nsec);
    
    return $self->add($duration_nsec);
  }
  
  method after : int ($go_time : Go::Time) {
    
    unless ($go_time) {
      die "The time \$go_time must be defined.";
    }
    
    my $tv_interval = &_tv_interval($self, $go_time);
    
    return $tv_interval > 0;
  }
  
  method before : int ($go_time : Go::Time) {
    
    unless ($go_time) {
      die "The time \$go_time must be defined.";
    }
    
    my $tv_interval = &_tv_interval($self, $go_time);
    
    return $tv_interval < 0;
  }
  
  private static method _tv_interval : double ($go_time1 : Go::Time, $go_time2 : Go::Time) {
    
    my $tv_interval = 0.0;
    if ($go_time1->{mono_timespec} && $go_time2->{mono_timespec}) {
      $tv_interval = Sys::Time::Util->timespec_interval($go_time1->{mono_timespec}, $go_time2->{mono_timespec});
    }
    else {
      $tv_interval = Sys::Time::Util->timespec_interval($go_time1->real_timespec, $go_time2->real_timespec);
    }
    
    return $tv_interval;
  }
  
  method clone : Go::Time () {
    
    my $clone = new Go::Time;
    
    $clone->{real_sec} = $self->{real_sec};
    $clone->{real_nsec} = $self->{real_nsec};
    
    if ($self->{mono_timespec}) {
      $clone->{mono_timespec} = &_timespec_clone($self->{mono_timespec});
    }
    
    return $clone;
  }
  
  private static method _timespec_clone : Sys::Time::Timespec ($timespec : Sys::Time::Timespec) {
    
    my $clone = Sys::Time::Timespec->new;
    
    $clone->set_tv_sec($timespec->tv_sec);
    
    $clone->set_tv_nsec($timespec->tv_nsec);
    
    return $clone;
  }
  
  private method real_timespec : Sys::Time::Timespec () {
    
    my $ts = Sys::Time::Timespec->new;
    
    $ts->set_tv_sec($self->{real_sec});
    $ts->set_tv_nsec($self->{real_nsec});
    
    return $ts;
  }
  
}
