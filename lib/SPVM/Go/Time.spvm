# Copyright (c) 2026 Yuki Kimoto
# MIT License

class Go::Time {
  version_from Go;
  
  use Sys::Time::Util;
  use Sys::Time::Timespec;
  use Sys::Time::Constant as TIME;
  use Go::Duration_1l;
  
  # Interfaces
  interface Cloneable;
  
  # Fields
  has sec : long;
  
  has nsec : long;
  
  has has_monotonic_time : byte;
  
  has mono_duration_nsec : long;
  
  # Class Methods
  static method NANOSECOND  : long () { return 1L; }
  
  static method MICROSECOND : long () { return 1_000L; }
  
  static method MILLISECOND : long () { return 1_000_000L; }
  
  static method SECOND      : long () { return 1_000_000_000L; }
  
  static method MINUTE      : long () { return 60_000_000_000L; }
  
  static method HOUR        : long () { return 3_600_000_000_000L; }
  
  static method new_from_unix : Go::Time ($sec : long = 0, $nsec : long = 0) {
    
    my $self = new Go::Time;
    
    unless ($nsec >= 0 && $nsec < 1_000_000_000) {
      die "Invalid \$nsec value.";
    }
    
    $self->{sec} = $sec;
    
    $self->{nsec} = $nsec;
    
    return $self;
  }
  
  static method now : Go::Time () {
    
    my $self = new Go::Time;
    
    my $timespec = Time::HiRes->clock_gettime_timespec(TIME->CLOCK_REALTIME);
    
    my $mono_timespec = Time::HiRes->clock_gettime_timespec(TIME->CLOCK_MONOTONIC);
    
    $self->{sec} = $timespec->tv_sec;
    $self->{nsec} = $timespec->tv_nsec;
    
    $self->{mono_duration_nsec} = Go::Duration_1l->new_from_timespec($mono_timespec)->{nsec};
    
    $self->{has_monotonic_time} = 1;
    
    return $self;
  }
  
  # Instance Methods
  method unix : long () {
    return $self->{sec};
  }
  
  method nanosecond : long () {
    return $self->{nsec};
  }
  
  method add : Go::Time ($duration : Go::Duration_1l) {
    
    my $clone = $self->clone;
    
    my $timespec = Go::Duration_1l->to_timespec($duration);
    
    my $to_timespec = Sys::Time::Util->add_timespec($self->to_timespec, $timespec);
    $clone->{sec} = $to_timespec->tv_sec;
    $clone->{nsec} = $to_timespec->tv_nsec;
    
    if ($self->{has_monotonic_time}) {
      $clone->{mono_duration_nsec} += $duration->{nsec};
      $clone->{has_monotonic_time} = 1;
    }
    
    return $clone;
  }
  
  method sub : Go::Duration_1l ($go_time : Go::Time) {
    
    unless ($go_time) {
      die "Go::Time \$go_time must be defined.";
    }
    
    my $sub_duration : Go::Duration_1l;
    my $sub_nsec = 0L;
    if ($self->{has_monotonic_time} && $go_time->{has_monotonic_time}) {
      my $sub_duration_nsec = $self->{mono_duration_nsec} - $go_time->{mono_duration_nsec};
      $sub_duration = Go::Duration_1l->new($sub_duration_nsec);
    }
    else {
      my $timespec = $go_time->to_timespec;
      my $sub_timespec = Sys::Time::Util->subtract_timespec($self->to_timespec, $timespec);
      $sub_duration = Go::Duration_1l->new_from_timespec($sub_timespec);
    }
    
    return $sub_duration;
  }
  
  method add_sec : Go::Time ($seconds : double) {
    
    my $duration_nsec = Go::Duration_1l->new_from_sec($seconds);
    
    return $self->add($duration_nsec);
  }
  
  method equal : int ($go_time : Go::Time) {
    
    my $sub_duration = $self->sub($go_time);
    
    return $sub_duration->{nsec} == 0;
  }
  
  method after : int ($go_time : Go::Time) {
    
    my $sub_duration = $self->sub($go_time);
    
    return $sub_duration->{nsec} > 0;
  }
  
  method before : int ($go_time : Go::Time) {
    
    my $sub_duration = $self->sub($go_time);
    
    return $sub_duration->{nsec} < 0;
  }
  
  method clone : Go::Time () {
    
    my $clone = new Go::Time;
    
    copy_fields $clone, $self, Go::Time;
    
    return $clone;
  }
  
  method to_timespec : Sys::Time::Timespec () {
    
    my $ts = Sys::Time::Timespec->new;
    
    $ts->set_tv_sec($self->{sec});
    $ts->set_tv_nsec($self->{nsec});
    
    return $ts;
  }
  
  method _has_monotonic_time : int () {
    return $self->{has_monotonic_time};
  }
  
  method _mono_duration_nsec : long () {
    return $self->{mono_duration_nsec};
  }
  
}
