# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Go::Schedule::Task {
  allow Go::Schedule;
  
  use Sys::Time;
  use Sys::Time::Timeval;
  use Sys::Time::Timespec;
  use Sys::Poll::PollfdArray;
  use Sys::Poll::Constant as POLL;
  use Sys::Poll;
  
  has schedule : Go::Schedule;
  
  private static method new : Go::Schedule::Task () {
    
    my $self = new Go::Schedule::Task;
    
    return $self;
  }
  
  private method : void () {
    
    my $now_tv = Sys::Time::Timeval->new;
    
    my $loop_count = 0;
    while (1) {
      
      my $schedule = $self->{schedule};
      
      my $poll = $schedule->{poll};
      
      my $finshed = !$schedule->{coroutines}->length && !$poll->{coroutines_h}->keys_length;
      
      if ($finshed) {
        last;
      }
      
      my $check_io = 0;
      
      if ($loop_count % 60 == 0 || !$schedule->{coroutines}->length) {
        $check_io = 1;
      }
      
      if ($check_io) {
        
        my $poll_coroutines_h = $poll->{coroutines_h};
        
        my $poll_coroutines_length = $poll_coroutines_h->keys_length;
        
        if ($poll_coroutines_length > 0) {
          my $poll_fd_array = Sys::Poll::PollfdArray->new($poll_coroutines_length);
          
          my $poll_coroutine_addresses = $poll_coroutines_h->keys;
          
          my $poll_index = 0;
          for my $address (@$poll_coroutine_addresses) {
            
            my $poll_coroutine = (Go::Coroutine)$poll_coroutines_h->get($address);
            
            my $fd = $poll_coroutine->{fd};
            
            $poll_fd_array->set_fd($poll_index, $fd);
            
            my $is_write = $poll_coroutine->{is_write};
            
            if ($is_write) {
              $poll_fd_array->set_events($poll_index, POLL->POLLOUT);
            }
            else {
              $poll_fd_array->set_events($poll_index, POLL->POLLIN);
            }
            
            $poll_coroutine->{poll_index} = $poll_index;
            
            $poll_index++;
          }
          
          my $status = Sys::Poll->poll($poll_fd_array, $poll_coroutines_length, 0);
          
          my $ready_coroutine_addresses_list = StringList->new;
          
          for my $address (@$poll_coroutine_addresses) {
            my $poll_coroutine = (Go::Coroutine)$poll_coroutines_h->get($address);
            
            my $poll_index = $poll_coroutine->{poll_index};
            
            my $revent = $poll_fd_array->revents($poll_index);
            my $ready = 0;
            if ($revent & (POLL->POLLPRI | POLL->POLLNVAL | POLL->POLLHUP | POLL->POLLERR)) {
              $ready = 1;
            }
            elsif ($revent & POLL->POLLIN) {
              unless ($poll_coroutine->{is_write}) {
                $ready = 1;
              }
            }
            elsif ($revent & POLL->POLLOUT) {
              if ($poll_coroutine->{is_write}) {
                $ready = 1;
              }
            }
            
            if ($ready) {
              $ready_coroutine_addresses_list->push($address);
            }
          }
          
          
          my $ready_coroutine_addresses = $ready_coroutine_addresses_list->to_array;
          for my $address (@$ready_coroutine_addresses) {
            my $ready_coroutine = $poll_coroutines_h->delete($address);
            
            $schedule->{coroutines}->push($ready_coroutine);
          }
        }
      }
      else {
        my $coroutine = (Go::Coroutine)undef;
        
        if ($schedule->{coroutines}->length > 0) {
          $coroutine = (Go::Coroutine)$schedule->{coroutines}->shift;
        }
        
        if ($coroutine->{finished}) {
          $schedule->{current_coroutine} = undef;
        }
        else {
          my $over_deadline = 1;
          
          my $deadline_ts = $coroutine->{deadline};
          if ($deadline_ts) {
            
            my $now_sec = $now_tv->tv_sec;
            my $now_nsec = 1000 * $now_tv->tv_usec;
            
            my $deadline_sec = $deadline_ts->tv_sec;
            my $deadline_nsec = $deadline_ts->tv_nsec;
            
            Sys::Time->gettimeofday($now_tv, undef);
            
            if ($now_sec > $deadline_sec || ($now_sec == $deadline_sec && $deadline_nsec > $deadline_nsec)) {
              $coroutine->{deadline} = undef;
            }
            else {
              $schedule->{coroutines}->push($coroutine);
              $over_deadline = 0;
            }
          }
          
          
          my $fd = $coroutine->{fd};
          if ($fd >= 0) {
            my $coroutine_address = Fn->to_address($coroutine);
            $schedule->{poll}->{coroutines_h}->set($coroutine_address, $coroutine);
          }
          else {
            if ($over_deadline) {
              
              my $schedule_task_coroutine = $schedule->{schedule_task_coroutine};
              
              $schedule->{coroutines}->push($coroutine);
              
              $coroutine->{return_back} = $schedule_task_coroutine;
              
              $schedule->{current_coroutine} = $coroutine;
              
              Go::Coroutine->transfer($schedule_task_coroutine, $coroutine);
            }
          }
        }
      }
      
      $loop_count++;
    }
  }
  
}
