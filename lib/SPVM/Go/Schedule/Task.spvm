# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Go::Schedule::Task {
  allow Go::Schedule;
  
  use Sys::Time;
  use Sys::Time::Timeval;
  
  has schedule : Go::Schedule;
  
  private static method new : Go::Schedule::Task () {
    
    my $self = new Go::Schedule::Task;
    
    return $self;
  }
  
  private method : void () {
    
    my $now_tv = Sys::Time::Timeval->new;
    
    while (1) {
      
      my $schedule = $self->{schedule};
      
      my $schedule_task_coroutine = $schedule->{schedule_task_coroutine};
      
      my $coroutine = (Go::Coroutine)$schedule->{coroutine_queue}->dequeue;
      
      if ($coroutine) {
        if ($coroutine->{finished}) {
          $schedule->{current_coroutine} = undef;
        }
        else {
          
          my $deadline = $coroutine->{deadline};
          if ($deadline > 0) {
            Sys::Time->gettimeofday($now_tv, undef);
            
            my $now = $now_tv->tv_sec + 0.000001 * $now_tv->tv_usec;
            
            unless ($now > $deadline) {
              $schedule->{coroutine_queue}->enqueue($coroutine);
              next;
            }
          }
          
          $schedule->{coroutine_queue}->enqueue($coroutine);
          
          $coroutine->{return_back} = $schedule_task_coroutine;
          
          $schedule->{current_coroutine} = $coroutine;
          
          Go::Coroutine->transfer($schedule_task_coroutine, $coroutine);
        }
      }
      else {
        last;
      }
    }
  }
  
}
