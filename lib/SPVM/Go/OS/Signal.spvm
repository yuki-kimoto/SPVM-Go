# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Go::OS::Signal {
  version_from Go;
  use Go;
  use Go::Channel;
  use Sys::Signal;
  use Sys::IO::Constant as IO;
  use Sys;
  use Errno;
  use Thread;
  use Go::Sync::WaitGroup;
  use Hash;
  use Sys::Signal::Handler;
  use Sync::Mutex;
  
  # Class Variables
  our $SIGNAL_READ_FD : int;
  INIT {
    $SIGNAL_READ_FD = -1;
  }
  
  our $SIGNAL_WRITE_FD : int;
  INIT {
    $SIGNAL_WRITE_FD = -1;
  }
  
  our $NOTIFIED_SIGNALS_H : cache Hash of Go::Channel[];
  
  our $SIGNAL_HANDLER_TRHEAD : Thread;
  
  our $MUTEX : Sync::Mutex;
  INIT {
    $MUTEX = Sync::Mutex->new;
  }
  
  static method ignore : void ($signal : int) {
    
    Sys::Signal->signal($signal, Sys::Signal->SIG_GO);
    
    $MUTEX->lock;
    
    $NOTIFIED_SIGNALS_H->{"$signal"} = new Go::Channel[0];
    
    $MUTEX->unlock;
  }
  
  static method notify : void ($channel : Go::Channel, $signal : int) {
    
    Sys::Signal->signal($signal, Sys::Signal->SIG_GO);
    
    unless ($channel) {
      die "\$channel must be defined.";
    }
    
    $MUTEX->lock;
    
    $NOTIFIED_SIGNALS_H //= Hash->new;
    
    $NOTIFIED_SIGNALS_H->{"$signal"} //= new Go::Channel[0];
    
    List->new_ref($NOTIFIED_SIGNALS_H->{"$signal"})->push($channel);
    
    $MUTEX->unlock;
    
    unless (&is_handler_running) {
      &start_handler;
    }
    
    Go->go(method : void () {
      
      my $buffer = (mutable string)new_string_len 4;
      
      my $thread = Thread->new([$buffer : mutable string] method : void () {
        Sys::IO->read($SIGNAL_READ_FD, $buffer, 4);
      });
      
      $thread->join;
      
      my $numbers = new int [1];
      
      Fn->memcpy($numbers, 0, $buffer, 0, 4);
      
      my $got_signal = $numbers->[0];
      
      $MUTEX->lock;
      
      if (my $channels = $NOTIFIED_SIGNALS_H->{"$got_signal"}) {
        for my $channel (@$channels) {
          my $select = Go->new_select;
          $select->set_non_blocking(1);
          $select->add_write($channel, $got_signal);
          $select->select;
        }
      }
      
      $MUTEX->unlock;
    });
  }
  
  static method stop : void ($channel : Go::Channel, $signal : int) {
    
    Sys::Signal->signal($signal, Sys::Signal->SIG_GO);
    
    $MUTEX->lock;
    
    my $channels = $NOTIFIED_SIGNALS_H->{"$signal"} // new Go::Channel[0];
    my $new_channels = (List of Go::Channel)List->new(new Go::Channel[0]);
    for my $_ (@$channels) {
      unless ($_ == $channel) {
        $new_channels->push($_);
      }
    }
    
    $NOTIFIED_SIGNALS_H->{"$signal"} = $new_channels->to_array;
    
    $MUTEX->unlock;
  }
  
  static method start_handler : void () {
    
    if (&is_handler_running) {
      die "Go::OS::Signal handler is already running.";
    }
    
    my $signal_read_fd = -1;
    my $signal_write_fd = -1;
    
    Sys->pipe(\$signal_read_fd, \$signal_write_fd);
    
    $SIGNAL_READ_FD = $signal_read_fd;
    
    $SIGNAL_WRITE_FD = $signal_write_fd;
    
    Sys::Signal->SET_SIG_GO_WRITE_FD($signal_write_fd);
  }
  
  static method stop_handler : void () {
    
    unless (&is_handler_running) {
      die "Go::OS::Signal handler is already stopped.";
    }
    
    $MUTEX->lock;
    
    for my $signal (@{$NOTIFIED_SIGNALS_H->keys}) {
      Sys::Signal->signal((int)$signal, Sys::Signal->SIG_DFL);
    }
    
    $NOTIFIED_SIGNALS_H = undef;
    
    $MUTEX->unlock;
    
    Sys::IO->close($SIGNAL_WRITE_FD);
    $SIGNAL_WRITE_FD = -1;
    
    Sys::IO->close($SIGNAL_READ_FD);
    $SIGNAL_READ_FD = -1;
  }
  
  static method is_handler_running : int () {
    
    return $SIGNAL_READ_FD > -1;
  }
  
}
