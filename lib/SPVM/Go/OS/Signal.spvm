# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Go::OS::Signal {
  version_from Go;
  use Go;
  use Go::Channel;
  use Sys::Signal;
  use Sys::IO::Constant as IO;
  use Sys;
  use Errno;
  use Thread;
  use Go::Sync::WaitGroup;
  use Hash;
  
  # Class Variables
  our $READ_FD : int;
  
  our $SIGNALS_H : cache Hash of Go::Channel[];
  
  our $SIGNAL_HANDLER_RUNNING : byte;
  
  static method ignore : void ($signal : int) {
    
    $SIGNALS_H->delete("$signal");
    
    Sys::Signal->signal($signal, Sys::Signal->SIG_IGN);
  }
  
  static method notify : void ($channel : Go::Channel, $signal : int) {
    
    unless ($channel) {
      die "\$channel must be defined.";
    }
    
    $SIGNALS_H //= Hash->new;
    
    $SIGNALS_H->{"$signal"} //= new Go::Channel[0];
    
    List->new_ref($SIGNALS_H->{"$signal"})->push($channel);
    
    unless (&is_handler_running) {
      &start_handler;
    }
    
    Sys::Signal->signal($signal, Sys::Signal->SIG_GO);
    
    Go->go(method : void () {
      my $buffer = (mutable string)new_string_len 4;
      
      my $use_thread = 0;
      if (Sys::OS->is_windows) {
        $use_thread = 1;
      }
      
      if ($use_thread) {
        
        my $wg = Go::Sync::WaitGroup->new;
        
        $wg->add(1);
        
        my $thread = Thread->new([$wg : Go::Sync::WaitGroup, $buffer : mutable string] method : void () {
          Fn->defer([$wg : Go::Sync::WaitGroup] method : void () {
            $wg->done;
          });
          
          Sys::IO->read($READ_FD, $buffer, 4);
        });
        
        $wg->wait;
        
        $thread->join;
      }
      else {
        while (1) {
          eval { Sys::IO->read($READ_FD, $buffer, 4); }
          
          if ($@) {
            if (Errno->errno == Errno->EWOULDBLOCK || Errno->errno == Errno->EINTR) {
              Go->gosched_io_read($READ_FD);
            }
            else {
              die $@;
            }
          }
          else {
            last;
          }
        }
      }
      
      my $numbers = new int [1];
      
      Fn->memcpy($numbers, 0, $buffer, 0, 4);
      
      my $got_signal = $numbers->[0];
      
      if (my $channels = $SIGNALS_H->{"$got_signal"}) {
        for my $channel (@$channels) {
          my $select = Go->new_select;
          $select->set_non_blocking(1);
          $select->add_write($channel, $got_signal);
          $select->select;
        }
      }
    });
  }
  
  static method stop : void ($channel : Go::Channel, $signal : int) {
    
    die "TODO";
  }
  
  static method start_handler : void () {
    
    if ($SIGNAL_HANDLER_RUNNING) {
      die "Go::OS::Signal handler is already running.";
    }
    
    $SIGNAL_HANDLER_RUNNING = 1;
    
    my $read_fd = -1;
    my $write_fd = -1;
    
    Sys->pipe(\$read_fd, \$write_fd);
    
    $READ_FD = $read_fd;
    
    unless (Sys::OS->is_windows) {
      Sys->fcntl($READ_FD, IO->F_SETFL, IO->O_NONBLOCK);
    }
    
    Sys::Signal->SET_SIG_GO_WRITE_FD($write_fd);
  }
  
  static method stop_handler : void () {
    
    unless ($SIGNAL_HANDLER_RUNNING) {
      die "Go::OS::Signal handler is already stopped.";
    }
    
    $SIGNAL_HANDLER_RUNNING = 0;
  }
  
  static method is_handler_running : int () {
    
    return $SIGNAL_HANDLER_RUNNING;
  }
  
}
