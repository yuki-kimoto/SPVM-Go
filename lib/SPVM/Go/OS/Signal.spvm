# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Go::OS::Signal {
  version_from Go;
  
  allow Go::Schedule;
  
  use Go;
  use Go::Channel;
  use Sys::Signal;
  use Sys::IO::Constant as IO;
  use Sys;
  use Errno;
  use Thread;
  use Go::Sync::WaitGroup;
  use Hash;
  use Sys::Signal::Handler;
  use Sync::Mutex;
  use Sys::Process;
  
  # Class Variables
  our $SIGNAL_READ_FD : int;
  INIT {
    $SIGNAL_READ_FD = -1;
  }
  
  our $SIGNAL_WRITE_FD : int;
  INIT {
    $SIGNAL_WRITE_FD = -1;
  }
  
  our $NOTIFIED_SIGNALS_H : cache Hash of Go::Channel[];
  
  our $SIGNAL_HANDLER_TRHEAD : cache Thread;
  
  our $MUTEX : Sync::Mutex;
  INIT {
    $MUTEX = Sync::Mutex->new;
  }
  
  static method ignore : void ($signal : int) {
    
    Sys::Signal->signal($signal, Sys::Signal->SIG_GO);
    
    $MUTEX->lock;
    
    $NOTIFIED_SIGNALS_H->{"$signal"} = new Go::Channel[0];
    
    $MUTEX->unlock;
  }
  
  static method notify : void ($channel : Go::Channel, $signal : int) {
    
    Sys::Signal->signal($signal, Sys::Signal->SIG_GO);
    
    unless ($channel) {
      die "\$channel must be defined.";
    }
    
    $MUTEX->lock;
    
    $NOTIFIED_SIGNALS_H->{"$signal"} //= new Go::Channel[0];
    
    List->new_ref($NOTIFIED_SIGNALS_H->{"$signal"})->push($channel);
    
    $MUTEX->unlock;
  }
  
  static method stop : void ($channel : Go::Channel, $signal : int) {
    
    Sys::Signal->signal($signal, Sys::Signal->SIG_GO);
    
    $MUTEX->lock;
    
    my $channels = $NOTIFIED_SIGNALS_H->{"$signal"} // new Go::Channel[0];
    my $new_channels = (List of Go::Channel)List->new(new Go::Channel[0]);
    for my $_ (@$channels) {
      unless ($_ == $channel) {
        $new_channels->push($_);
      }
    }
    
    $NOTIFIED_SIGNALS_H->{"$signal"} = $new_channels->to_array;
    
    $MUTEX->unlock;
  }
  
  private static method start_handler : void () {
    
    if (&_is_handler_running) {
      die "Go::OS::Signal handler is already running.";
    }
    
    my $signal_read_fd = -1;
    my $signal_write_fd = -1;
    
    Sys->pipe(\$signal_read_fd, \$signal_write_fd);
    
    $SIGNAL_READ_FD = $signal_read_fd;
    
    $SIGNAL_WRITE_FD = $signal_write_fd;
    
    Sys::Signal->SET_SIG_GO_WRITE_FD($signal_write_fd);
    
    $MUTEX->lock;
    
    $NOTIFIED_SIGNALS_H = Hash->new;
    
    $MUTEX->unlock;
    
    $SIGNAL_HANDLER_TRHEAD = Thread->new(method : void () {
      
      while (1) {
        unless ($SIGNAL_READ_FD > -1) {
          return;
        }
        
        my $buffer = (mutable string)new_string_len 4;
        
        eval { Sys::IO->read($SIGNAL_READ_FD, $buffer, 4); }
        
        if ($@) {
          return;
        }
        
        my $numbers = new int [1];
        
        Fn->memcpy($numbers, 0, $buffer, 0, 4);
        
        my $got_signal = $numbers->[0];
        
        $MUTEX->lock;
        
        if ($NOTIFIED_SIGNALS_H && (my $channels = $NOTIFIED_SIGNALS_H->{"$got_signal"})) {
          for my $channel (@$channels) {
            my $select = Go->new_select;
            $select->set_non_blocking(1);
            $select->add_write($channel, $got_signal);
            $select->select;
          }
        }
        
        $MUTEX->unlock;
        
        Sys::Process->usleep(10_000); # 10ms
      }
      
    });
    
  }
  
  static method _stop_handler : void () {
    
    unless (&_is_handler_running) {
      die "Go::OS::Signal handler is already stopped.";
    }
    
    $MUTEX->lock;
    
    if ($NOTIFIED_SIGNALS_H) {
      for my $signal (@{$NOTIFIED_SIGNALS_H->keys}) {
        Sys::Signal->signal((int)$signal, Sys::Signal->SIG_DFL);
      }
    }
    $NOTIFIED_SIGNALS_H = undef;
    
    $MUTEX->unlock;
    
    my $signal_write_fd = $SIGNAL_WRITE_FD;
    $SIGNAL_WRITE_FD = -1;
    
    my $signal_read_fd = $SIGNAL_READ_FD;
    $SIGNAL_READ_FD = -1;
    
    Sys::Signal->SET_SIG_GO_WRITE_FD(-1);
    
    Sys::IO->close($signal_write_fd);
    
    Sys::IO->close($signal_read_fd);
    
    $SIGNAL_HANDLER_TRHEAD->join;
    
    $SIGNAL_HANDLER_TRHEAD = undef;
  }
  
  static method _is_handler_running : int () {
    
    return $SIGNAL_READ_FD > -1;
  }
  
}
