# Copyright (c) 2023 Yuki Kimoto
# MIT License

class Go {
  version "0.024";
  
  use Go::Channel;
  use Go::Schedule;
  use Callback;
  use Go::Select;
  use Go::Duration_1l;
  
  our $GO : Go;
  
  has schedule : Go::Schedule;
  
  INIT {
    my $go = new Go;
    
    my $schedule = Go::Schedule->new;
    
    $go->{schedule} = $schedule;
    
    $GO = $go;
  }
  
  static method go : void ($task : Callback) {
    
    my $schedule = $GO->{schedule};
    
    $schedule->add_task($task);
  }
  
  static method make : Go::Channel ($capacity : int = 0) {
    
    my $schedule = $GO->{schedule};
    
    my $channel = Go::Channel->new({schedule => $schedule, capacity => $capacity});
    
    return $channel;
  }
  
  static method new_select : Go::Select () {
    
    my $schedule = $GO->{schedule};
    
    my $select = Go::Select->new($schedule);
    
    return $select;
  }
  
  static method gosched : void () {
    
    my $schedule = $GO->{schedule};
    
    $schedule->schedule;
  }
  
  static method sleep : void ($duration : Go::Duration_1l) {
    
    my $schedule = $GO->{schedule};
    
    $schedule->schedule($duration->{nsec});
  }
  
  static method sleep_sec : void ($sec : double = 0) {
    
    my $duration = Go::Duration_1l->new_from_sec($sec);
    
    &sleep($duration);
  }
  
  static method gosched_io_read : void ($fd : int, $timeout_duration : Go::Duration_1l) {
    
    my $schedule = $GO->{schedule};
    
    $schedule->schedule_io_read($fd, $timeout_duration->{nsec});
  }
  
  static method gosched_io_read_sec : void ($fd : int, $timeout_sec : double = 0) {
    
    my $timeout_duration = Go::Duration_1l->new_from_sec($timeout_sec);
    
    &gosched_io_read($fd, $timeout_duration);
  }
  
  static method gosched_io_write : void ($fd : int, $timeout_duration : Go::Duration_1l) {
    
    my $schedule = $GO->{schedule};
    
    $schedule->schedule_io_write($fd, $timeout_duration->{nsec});
  }
  
  static method gosched_io_write_sec : void ($fd : int, $timeout_sec : double = 0) {
    
    my $timeout_duration = Go::Duration_1l->new_from_sec($timeout_sec);
    
    &gosched_io_write($fd, $timeout_duration);
  }
  
  private method DESTROY : void () {
    
    my $schedule = $self->{schedule};
    
  }
  
  static method ENV_DEBUG : int () {
    
    my $debug = (int)Sys->env("SPVM_GO_DEBUG");
    
    return $debug;
  }
  
}

