class TestCase::Go::Time {
  use Go::Time;
  use Sys::Time::Util;
  
  static method basic : int () {
    
    return 1;
  }
  
  static method new_from_unix : int () {
    
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == $sec) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $nsec) {
        return 0;
      }
      
      if ($go_time->_has_monotonic_time) {
        return 0;
      }
      
      unless ($go_time->_mono_duration_nsec == 0) {
        return 0;
      }
      
    }
    
    {
      my $sec = 1;
      my $nsec = 0;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == $sec) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $nsec) {
        return 0;
      }
      
    }
    
    {
      my $sec = 1;
      my $nsec = 1_000_000_000 - 1;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == $sec) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $nsec) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->new_from_unix;
      
      unless ($go_time->unix == 0) {
        return 0;
      }
      
      unless ($go_time->nanosecond == 0) {
        return 0;
      }
      
    }
    
    # Exception
    {
      {
        my $sec = 1;
        my $nsec = -1;
        eval { my $go_time = Go::Time->new_from_unix($sec, $nsec); }
        
        unless ($@) {
          return 0;
        }
      }
      
      {
        my $sec = 1;
        my $nsec = -1;
        eval { my $go_time = Go::Time->new_from_unix($sec, $nsec); }
        
        unless ($@) {
          return 0;
        }
      }
      
      {
        my $sec = 1;
        my $nsec = 1_000_000_000;
        eval { my $go_time = Go::Time->new_from_unix($sec, $nsec); }
        
        unless ($@) {
          return 0;
        }
      }
      
    }
    
    return 1;
  }
  
  static method now : int () {
    
    {
      my $go_time = Go::Time->now;
      
      unless ($go_time->_has_monotonic_time) {
        return 0;
      }
      
      diag "[Test Output]now:\n" . dump $go_time;
    }
    
    return 1;
  }
  
  static method add : int () {
    
    {
      my $sec = 1;
      my $nsec = 900_000_000;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $ret = $go_time->add(Go::Duration_1l->new(100_000_000));
      
      unless ($ret->unix == 2) {
        return 0;
      }
      
      unless ($ret->nanosecond == 0) {
        return 0;
      }
      
      if ($ret->_has_monotonic_time) {
        return 0;
      }
      
      unless ($ret->_mono_duration_nsec == 0) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $go_time_sec = $go_time->unix;
      my $go_time_nsec = $go_time->nanosecond;
      my $go_time_mono_duration_nsec = $go_time->_mono_duration_nsec;
      
      my $ret = $go_time->add(Go::Duration_1l->new(1));
      
      unless ($ret->_has_monotonic_time) {
        return 0;
      }
      
      unless ($ret->_mono_duration_nsec - $go_time_mono_duration_nsec == 1) {
        return 0;
      }
      
      my $ret_sec = $ret->unix;
      my $ret_nsec = $ret->nanosecond;
      my $ret_mono_duration_nsec = $ret->_mono_duration_nsec;
      
      my $diff_timespec = Sys::Time::Util->subtract_timespec($ret->to_timespec, $go_time->to_timespec);
      unless ($diff_timespec->tv_sec == 0) {
        return 0;
      }
      
      unless ($diff_timespec->tv_nsec == 1) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  
  static method to_timespec : int () {
    
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $ret = $go_time->to_timespec;
      
      unless ($ret->tv_sec == 1) {
        return 0;
      }
      
      unless ($ret->tv_nsec == 2) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
}

