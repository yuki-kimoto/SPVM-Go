class TestCase::Go::Time {
  use Go::Time;
  use Sys::Time::Util;
  
  static method basic : int () {
    
    # unix
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == 1) {
        return 0;
      }
    }
    
    # nanosecond
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->nanosecond == 2) {
        return 0;
      }
    }
    
    # unix_nano
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      warn $go_time->unix_nano;
      
      unless ($go_time->unix_nano == 1_000_000_002) {
        return 0;
      }
    }
    
    # clone
    {
      my $go_time = Go::Time->now;
      my $ret = $go_time->clone;
      
      if ($go_time == $ret) {
        return 0;
      }
      
      unless ($go_time->unix == $ret->unix) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $ret->nanosecond) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $ret->nanosecond) {
        return 0;
      }
      
      unless ($go_time->_has_monotonic_time == $ret->_has_monotonic_time) {
        return 0;
      }
      
      unless ($go_time->_mono_duration_nsec == $ret->_mono_duration_nsec) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method new_from_unix : int () {
    
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == $sec) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $nsec) {
        return 0;
      }
      
      if ($go_time->_has_monotonic_time) {
        return 0;
      }
      
      unless ($go_time->_mono_duration_nsec == 0) {
        return 0;
      }
      
    }
    
    {
      my $sec = 1;
      my $nsec = 0;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == $sec) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $nsec) {
        return 0;
      }
      
    }
    
    {
      my $sec = 1;
      my $nsec = 1_000_000_000 - 1;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == $sec) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $nsec) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->new_from_unix;
      
      unless ($go_time->unix == 0) {
        return 0;
      }
      
      unless ($go_time->nanosecond == 0) {
        return 0;
      }
      
    }
    
    # Exception
    {
      {
        my $sec = 1;
        my $nsec = -1;
        eval { my $go_time = Go::Time->new_from_unix($sec, $nsec); }
        
        unless ($@) {
          return 0;
        }
      }
      
      {
        my $sec = 1;
        my $nsec = -1;
        eval { my $go_time = Go::Time->new_from_unix($sec, $nsec); }
        
        unless ($@) {
          return 0;
        }
      }
      
      {
        my $sec = 1;
        my $nsec = 1_000_000_000;
        eval { my $go_time = Go::Time->new_from_unix($sec, $nsec); }
        
        unless ($@) {
          return 0;
        }
      }
      
    }
    
    return 1;
  }
  
  static method now : int () {
    
    {
      my $go_time = Go::Time->now;
      
      unless ($go_time->_has_monotonic_time) {
        return 0;
      }
      
      diag "[Test Output]now:\n" . dump $go_time;
    }
    
    return 1;
  }
  
  static method add : int () {
    
    {
      my $sec = 1;
      my $nsec = 900_000_000;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $ret = $go_time->add(Go::Duration_1l->new(100_000_000));
      
      unless ($ret->unix == 2) {
        return 0;
      }
      
      unless ($ret->nanosecond == 0) {
        return 0;
      }
      
      if ($ret->_has_monotonic_time) {
        return 0;
      }
      
      unless ($ret->_mono_duration_nsec == 0) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $go_time_sec = $go_time->unix;
      my $go_time_nsec = $go_time->nanosecond;
      my $go_time_mono_duration_nsec = $go_time->_mono_duration_nsec;
      
      my $ret = $go_time->add(Go::Duration_1l->new(1));
      
      unless ($ret->_has_monotonic_time) {
        return 0;
      }
      
      unless ($ret->_mono_duration_nsec - $go_time_mono_duration_nsec == 1) {
        return 0;
      }
      
      my $ret_sec = $ret->unix;
      my $ret_nsec = $ret->nanosecond;
      my $ret_mono_duration_nsec = $ret->_mono_duration_nsec;
      
      my $diff_timespec = Sys::Time::Util->subtract_timespec($ret->to_timespec, $go_time->to_timespec);
      unless ($diff_timespec->tv_sec == 0) {
        return 0;
      }
      
      unless ($diff_timespec->tv_nsec == 1) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method add_sec : int () {
    
    {
      my $sec = 1;
      my $nsec = 0;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $ret = $go_time->add_sec(0.5);
      
      unless ($ret->unix == 1) {
        return 0;
      }
      
      unless ($ret->nanosecond == 500_000_000) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method sub : int () {
    
    # Both non-monotonic
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->sub($go_time);
      
      unless ($ret->{nsec} = 1) {
        return 0;
      }
      
    }
    
    # Both monotonic
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->sub($go_time);
      
      unless ($ret->{nsec} = 1) {
        return 0;
      }
      
    }
    
    # Monotonic and non-monotonic
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->sub(Go::Time->new_from_unix($add->unix, $add->nanosecond));
      
      unless ($ret->{nsec} = 1) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method to_timespec : int () {
    
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $ret = $go_time->to_timespec;
      
      unless ($ret->tv_sec == 1) {
        return 0;
      }
      
      unless ($ret->tv_nsec == 2) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method equal : int () {
    
    {
      my $go_time = Go::Time->now;
      
      my $ret = $go_time->equal($go_time);
      
      unless ($ret) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->equal($go_time);
      
      if ($ret) {
        return 0;
      }
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(-1));
      
      my $ret = $add->equal($go_time);
      
      if ($ret) {
        return 0;
      }
    }
    
    return 1;
  }
  
  static method after : int () {
    
    {
      my $go_time = Go::Time->now;
      
      my $ret = $go_time->after($go_time);
      
      if ($ret) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->after($go_time);
      
      unless ($ret) {
        return 0;
      }
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(-1));
      
      my $ret = $add->after($go_time);
      
      if ($ret) {
        return 0;
      }
    }
    
    return 1;
  }
  
  static method before : int () {
    
    {
      my $go_time = Go::Time->now;
      
      my $ret = $go_time->before($go_time);
      
      if ($ret) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->before($go_time);
      
      if ($ret) {
        return 0;
      }
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(-1));
      
      my $ret = $add->before($go_time);
      
      unless ($ret) {
        return 0;
      }
    }
    
    return 1;
  }
  
}

