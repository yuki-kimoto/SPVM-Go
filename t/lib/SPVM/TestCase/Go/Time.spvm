class TestCase::Go::Time {
  use Go::Time;
  use Sys::Time::Util;
  
  static method basic : int () {
    
    # unix
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == 1) {
        return 0;
      }
    }
    
    # nanosecond
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->nanosecond == 2) {
        return 0;
      }
    }
    
    # unix_nano
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix_nano == 1_000_000_002) {
        return 0;
      }
    }
    
    # clone
    {
      my $go_time = Go::Time->now;
      my $ret = $go_time->clone;
      
      if ($go_time == $ret) {
        return 0;
      }
      
      unless ($go_time->unix == $ret->unix) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $ret->nanosecond) {
        return 0;
      }
      
      unless ($go_time->_has_monotonic_time == $ret->_has_monotonic_time) {
        return 0;
      }
      
      unless ($go_time->_mono_duration_nsec == $ret->_mono_duration_nsec) {
        return 0;
      }
      
    }
    
    # NANOSECOND
    unless (Go::Time->NANOSECOND == 1L) {
      return 0;
    }
    
    # MICROSECOND
    unless (Go::Time->MICROSECOND == 1_000L) {
      return 0;
    }
    
    # MILLISECOND
    unless (Go::Time->MILLISECOND == 1_000_000L) {
      return 0;
    }
    
    # SECOND
    unless (Go::Time->SECOND == 1_000_000_000L) {
      return 0;
    }
    
    # MINUTE
    unless (Go::Time->MINUTE == 60_000_000_000L) {
      return 0;
    }
    
    # HOUR
    unless (Go::Time->HOUR == 3_600_000_000_000L) {
      return 0;
    }
    
    return 1;
  }
  
  static method new_from_unix : int () {
    
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == $sec) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $nsec) {
        return 0;
      }
      
      if ($go_time->_has_monotonic_time) {
        return 0;
      }
      
      unless ($go_time->_mono_duration_nsec == 0) {
        return 0;
      }
      
    }
    
    {
      my $sec = 1;
      my $nsec = 0;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == $sec) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $nsec) {
        return 0;
      }
      
    }
    
    {
      my $sec = 1;
      my $nsec = 1_000_000_000 - 1;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      unless ($go_time->unix == $sec) {
        return 0;
      }
      
      unless ($go_time->nanosecond == $nsec) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->new_from_unix;
      
      unless ($go_time->unix == 0) {
        return 0;
      }
      
      unless ($go_time->nanosecond == 0) {
        return 0;
      }
      
    }
    
    # Exception
    {
      {
        my $sec = 1;
        my $nsec = -1;
        eval { my $go_time = Go::Time->new_from_unix($sec, $nsec); }
        
        unless ($@) {
          return 0;
        }
      }
      
      {
        my $sec = 1;
        my $nsec = -1;
        eval { my $go_time = Go::Time->new_from_unix($sec, $nsec); }
        
        unless ($@) {
          return 0;
        }
      }
      
      {
        my $sec = 1;
        my $nsec = 1_000_000_000;
        eval { my $go_time = Go::Time->new_from_unix($sec, $nsec); }
        
        unless ($@) {
          return 0;
        }
      }
      
    }
    
    return 1;
  }
  
  static method now : int () {
    
    {
      my $go_time = Go::Time->now;
      
      unless ($go_time->_has_monotonic_time) {
        return 0;
      }
      
      diag "[Test Output]now:\n" . dump $go_time;
    }
    
    return 1;
  }
  
  static method add : int () {
    
    {
      my $sec = 1;
      my $nsec = 900_000_000;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $ret = $go_time->add(Go::Duration_1l->new(100_000_000));
      
      unless ($ret->unix == 2) {
        return 0;
      }
      
      unless ($ret->nanosecond == 0) {
        return 0;
      }
      
      if ($ret->_has_monotonic_time) {
        return 0;
      }
      
      unless ($ret->_mono_duration_nsec == 0) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $go_time_sec = $go_time->unix;
      my $go_time_nsec = $go_time->nanosecond;
      my $go_time_mono_duration_nsec = $go_time->_mono_duration_nsec;
      
      my $ret = $go_time->add(Go::Duration_1l->new(1));
      
      unless ($ret->_has_monotonic_time) {
        return 0;
      }
      
      unless ($ret->_mono_duration_nsec - $go_time_mono_duration_nsec == 1) {
        return 0;
      }
      
      my $ret_sec = $ret->unix;
      my $ret_nsec = $ret->nanosecond;
      my $ret_mono_duration_nsec = $ret->_mono_duration_nsec;
      
      my $diff_timespec = Sys::Time::Util->subtract_timespec($ret->to_timespec, $go_time->to_timespec);
      unless ($diff_timespec->tv_sec == 0) {
        return 0;
      }
      
      unless ($diff_timespec->tv_nsec == 1) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method add_sec : int () {
    
    {
      my $sec = 1;
      my $nsec = 0;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $ret = $go_time->add_sec(0.5);
      
      unless ($ret->unix == 1) {
        return 0;
      }
      
      unless ($ret->nanosecond == 500_000_000) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method sub : int () {
    
    # Both non-monotonic
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->sub($go_time);
      
      unless ($ret->{nsec} == 1) {
        return 0;
      }
      
    }
    
    # Both monotonic
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->sub($go_time);
      
      unless ($ret->{nsec} == 1) {
        return 0;
      }
      
    }
    
    # Monotonic and non-monotonic
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->sub(Go::Time->new_from_unix($go_time->unix, $go_time->nanosecond));
      
      unless ($ret->{nsec} == 1) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method to_timespec : int () {
    
    {
      my $sec = 1;
      my $nsec = 2;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $ret = $go_time->to_timespec;
      
      unless ($ret->tv_sec == 1) {
        return 0;
      }
      
      unless ($ret->tv_nsec == 2) {
        return 0;
      }
      
    }
    
    return 1;
  }
  
  static method equal : int () {
    
    {
      my $go_time = Go::Time->now;
      
      my $ret = $go_time->equal($go_time);
      
      unless ($ret) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->equal($go_time);
      
      if ($ret) {
        return 0;
      }
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(-1));
      
      my $ret = $add->equal($go_time);
      
      if ($ret) {
        return 0;
      }
    }
    
    return 1;
  }
  
  static method after : int () {
    
    {
      my $go_time = Go::Time->now;
      
      my $ret = $go_time->after($go_time);
      
      if ($ret) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->after($go_time);
      
      unless ($ret) {
        return 0;
      }
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(-1));
      
      my $ret = $add->after($go_time);
      
      if ($ret) {
        return 0;
      }
    }
    
    return 1;
  }
  
  static method before : int () {
    
    {
      my $go_time = Go::Time->now;
      
      my $ret = $go_time->before($go_time);
      
      if ($ret) {
        return 0;
      }
      
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(1));
      
      my $ret = $add->before($go_time);
      
      if ($ret) {
        return 0;
      }
    }
    
    {
      my $go_time = Go::Time->now;
      
      my $add = $go_time->add(Go::Duration_1l->new(-1));
      
      my $ret = $add->before($go_time);
      
      unless ($ret) {
        return 0;
      }
    }
    
    return 1;
  }
  
  static method rfc3339_nano : int () {
    
    # 1. Basic round-trip with full nanoseconds
    {
      my $sec = 1737032400L; # 2025-01-16T13:00:00Z
      my $nsec = 123456789L;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $rfc_str = $go_time->to_rfc3339_nano;
      unless ($rfc_str eq "2025-01-16T13:00:00.123456789Z") {
        diag $rfc_str;
        return 0;
      }
      
      my $back = Go::Time->new_from_rfc3339_nano($rfc_str);
      unless ($back->unix == $sec && $back->nanosecond == $nsec) {
        diag;
        return 0;
      }
    }
    
    # 2. Case with zero nanoseconds (trailing zeros and dot should be omitted)
    {
      my $sec = 1737032400L;
      my $nsec = 0L;
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $rfc_str = $go_time->to_rfc3339_nano;
      unless ($rfc_str eq "2025-01-16T13:00:00Z") {
        diag;
        return 0;
      }
      
      my $back = Go::Time->new_from_rfc3339_nano($rfc_str);
      unless ($back->unix == $sec && $back->nanosecond == 0) {
        diag;
        return 0;
      }
    }

    # 3. Case with trailing zeros in nanoseconds (should be trimmed in to_rfc3339_nano)
    {
      my $sec = 1737032400L;
      my $nsec = 123000000L; # 123ms
      my $go_time = Go::Time->new_from_unix($sec, $nsec);
      
      my $rfc_str = $go_time->to_rfc3339_nano;
      unless ($rfc_str eq "2025-01-16T13:00:00.123Z") {
        diag;
        return 0;
      }
      
      my $back = Go::Time->new_from_rfc3339_nano($rfc_str);
      unless ($back->nanosecond == 123000000L) {
        diag;
        return 0;
      }
    }
    
    # 4. Parsing from a string with shorter precision (e.g., only milliseconds)
    {
      my $rfc_str = "2025-01-16T13:00:00.12Z";
      my $back = Go::Time->new_from_rfc3339_nano($rfc_str);
      unless ($back->nanosecond == 120000000L) {
        diag;
        return 0;
      }
    }

    # Exception: Unsupported timezone (not UTC)
    {
      eval {
        my $bad_rfc = "2025-01-16T13:00:00+09:00";
        Go::Time->new_from_rfc3339_nano($bad_rfc);
      };
      unless ($@) {
        diag;
        return 0;
      }
    }

    # Exception: Invalid format (missing Z)
    {
      eval {
        my $bad_rfc = "2025-01-16T13:00:00";
        Go::Time->new_from_rfc3339_nano($bad_rfc);
      };
      unless ($@) {
        diag;
        return 0;
      }
    }
    
    return 1;
  }
  
}

