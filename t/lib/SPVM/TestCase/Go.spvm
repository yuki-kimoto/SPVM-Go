class TestCase::Go {
  use Go;
  use Sys;
  use Go::Sync::WaitGroup;
  use Point;
  
  our $RESULT : IntList;
  
  static method go_minimal : int () {
    
    $TestCase::Go::RESULT = IntList->new;
    
    Go->go(method : void () {
      $TestCase::Go::RESULT->push(2);
    });
    
    $TestCase::Go::RESULT->push(1);
    
    Go->gosched;
    
    $TestCase::Go::RESULT->push(3);
    
    unless (Array->equals_int($TestCase::Go::RESULT->to_array, [1, 2, 3])) {
      return 0;
    }
    
    $TestCase::Go::RESULT = undef;
    
    return 1;
  }
  
  static method go_basic : int () {
    
    $TestCase::Go::RESULT = IntList->new;
    
    Go->go(method : void () {
      
      $TestCase::Go::RESULT->push(2);
      
      Go->go(method : void () {
        $TestCase::Go::RESULT->push(4);
      });
      
      $TestCase::Go::RESULT->push(3);
    });
    
    $TestCase::Go::RESULT->push(1);
    
    Go->gosched;
    
    $TestCase::Go::RESULT->push(5);
    
    unless (Array->equals_int($TestCase::Go::RESULT->to_array, [1, 2, 3, 4, 5])) {
      return 0;
    }
    
    $TestCase::Go::RESULT = undef;
    
    return 1;
  }
  
  static method go_die : int () {
    
    $TestCase::Go::RESULT = IntList->new;
    
    Go->go(method : void () {
      die "Exception!.";
      
      $TestCase::Go::RESULT->push(1);
      
    });
    
    Go->go(method : void () {
      eval {
        die "Exception!.";
      }
      
      $TestCase::Go::RESULT->push(2);
      
    });
    
    Go->go(method : void () {
      TestCase::Go->error();
      
      $TestCase::Go::RESULT->push(3);
      
    });
    
    Go->gosched;
    
    unless (Array->equals_int($TestCase::Go::RESULT->to_array, [2])) {
      return 0;
    }
    
    $TestCase::Go::RESULT = undef;
    
    return 1;
  }
  
  static method error : void () {
    
    die "Error Method";
  }
  
  static method go_extra : int () {
    
    Go->go(method : void () {});
    
    Go->gosched;
    
    Go->gosched;
    
    return 1;
  }
  
  static method sleep : int () {
    
    Go->go(method : void () {
      
      my $seconds = 1.5;
      
      Go->sleep($seconds);
    });
    
    Go->gosched;
    
    return 1;
  }
  
  static method wait_group : int () {
    
    $TestCase::Go::RESULT = IntList->new;
    
    Go->go(method : void () {
      my $wg = Go::Sync::WaitGroup->new;
      
      $wg->add(2);
      
      Go->go([has wg : Go::Sync::WaitGroup = $wg] method : void () {
        
        Fn->defer([has wg : Go::Sync::WaitGroup = $self->{wg}] method : void () {
          $self->{wg}->done;
        });
        
        $TestCase::Go::RESULT->push(2);
        
      });
      
      Go->go([has wg : Go::Sync::WaitGroup = $wg] method : void () {
        Fn->defer([has wg : Go::Sync::WaitGroup = $self->{wg}] method : void () {
          $self->{wg}->done;
        });
        
        $TestCase::Go::RESULT->push(3);
      });
      
      $TestCase::Go::RESULT->push(1);
      
      $wg->wait;
      
      $TestCase::Go::RESULT->push(4);
    });
    
    Go->gosched;
    
    unless (Array->equals_int($TestCase::Go::RESULT->to_array, [1, 2, 3, 4])) {
      return 0;
    }
    
    $TestCase::Go::RESULT = undef;
    
    return 1;
  }
  static method select : int () {

    Go->go(method : void () {
      
      my $ch = Go->make;
      
      Go->go([has ch : Go::Channel = $ch] method : void () {
        
        my $ch = $self->{ch};
        
        $ch->write(1);
      });
      
      my $select = Go->new_select;
      
      $select->add_read($ch);
      
      my $result = $select->select;
      
      my $value = (int)$result->value;
      
      my $ok = $result->ok;
      
      warn "select 1:$value $ok";
    });
    
    Go->go(method : void () {
      
      my $ch0 = Go->make;
      
      my $ch1 = Go->make;
      
      my $ch2 = Go->make;
      
      my $ch3 = Go->make;
      
      Go->go([has ch0 : Go::Channel = $ch0, has ch1 : Go::Channel = $ch1, has ch2 : Go::Channel = $ch2, has ch3 : Go::Channel = $ch3] method : void () {
        
        my $ch0 = $self->{ch0};
        
        $ch0->write(1);
        
        my $ch1 = $self->{ch1};
        
        $ch1->write(2);
        
        my $ch2 = $self->{ch2};
        
        $ch2->write(3);
        
        my $ch3 = $self->{ch3};
        
        my $ok = 0;
        
        my $value = (int)$ch3->read(\$ok);
        
        warn "$value";
      });
      
      my $select = Go->new_select;
      
      $select->add_read($ch2);
      
      $select->add_read($ch1);
      
      $select->add_read($ch0);
      
      $select->add_write($ch3 => 4);
      
      while (1) {
        my $result = $select->select;
        
        my $ok = $result->ok;
        
        if ($ok) {
          my $ch = $result->channel;
          
          my $is_write = $result->is_write;
          
          if ($is_write) {
            $select->remove_write($ch);
          }
          else {
            my $value = (int)$result->value;
            
            warn "select 2:$value $ok " . Fn->to_address($ch);
            
            $select->remove_read($ch);
          }
        }
        
        if ($select->is_empty) {
          last;
        }
      }
      
    });
    
    Go->go(method : void () {
      
      my $ch0 = Go->make;
      
      my $ch1 = Go->make;
      
      my $ch2 = Go->make;
      
      my $ch3 = Go->make;
      
      Go->go([has ch0 : Go::Channel = $ch0, has ch1 : Go::Channel = $ch1, has ch2 : Go::Channel = $ch2, has ch3 : Go::Channel = $ch3] method : void () {
        
        my $ch0 = $self->{ch0};
        
        $ch0->write(1);
        
        my $ch1 = $self->{ch1};
        
        $ch1->write(2);
        
        my $ch2 = $self->{ch2};
        
        $ch2->write(3);
        
        my $ch3 = $self->{ch3};
        
        my $ok = 0;
        
        my $value = (int)$ch3->read(\$ok);
        
        warn "$value";
      });
      
      my $select = Go->new_select;
      
      $select->set_non_blocking(1);
      
      $select->add_read($ch2);
      
      $select->add_read($ch1);
      
      $select->add_read($ch0);
      
      $select->add_write($ch3 => 4);
      
      while (1) {
        my $result = $select->select;
        
        if ($result) {
          my $ok = $result->ok;
          
          if ($ok) {
            my $ch = $result->channel;
            
            my $is_write = $result->is_write;
            
            if ($is_write) {
              $select->remove_write($ch);
            }
            else {
              my $value = (int)$result->value;
              
              warn "select 2:$value $ok " . Fn->to_address($ch);
              
              $select->remove_read($ch);
            }
          }
          
          if ($select->is_empty) {
            last;
          }
        }
        else {
          warn "No read/write";
          Go->gosched;
        }
      }
      
    });
    
    Go->gosched;
    
    return 1;
  }
  
  static method channel_unbuffered_minimal : int () {
    
    $TestCase::Go::RESULT = IntList->new;
    
    Go->go(method : void () {
      
      my $ch = Go->make;
      
      Go->go([has ch : Go::Channel = $ch] method : void () {
        
        my $ch = $self->{ch};
        
        $ch->write(1);
      });
      
      my $ok = 0;
      
      my $value = (int)$ch->read(\$ok);
      
      $TestCase::Go::RESULT->push($value);
    });
    
    Go->gosched;
    
    unless (Array->equals_int($TestCase::Go::RESULT->to_array, [1])) {
      return 0;
    }
    
    $TestCase::Go::RESULT = undef;
    
    return 1;
  }
  
  static method channel_unbuffered : int () {
    
    $TestCase::Go::RESULT = IntList->new;
    
    Go->go(method : void () {
      
      my $ch = Go->make;
      
      Go->go([has ch : Go::Channel = $ch] method : void () {
        
        my $ch = $self->{ch};
        
        $ch->write(1);
        
        $ch->write(2);
        
        $ch->close;
      });
      
      my $ok = 0;
      
      my $value1 = (int)$ch->read(\$ok);
      
      $TestCase::Go::RESULT->push($value1);
      
      $TestCase::Go::RESULT->push($ok);
      
      my $value2 = (int)$ch->read(\$ok);
      
      $TestCase::Go::RESULT->push($value2);
      
      $TestCase::Go::RESULT->push($ok);
      my $value3 = $ch->read(\$ok);
      
      if ($value3) {
        $TestCase::Go::RESULT->push(1);
      }
      else {
        $TestCase::Go::RESULT->push(0);
      }
      
      $TestCase::Go::RESULT->push($ok);
    });
    
    Go->gosched;
    
    # value, ok
    my $expected = [
      1, 1,
      2, 1,
      0, 0
    ];
    
    unless (Array->equals_int($TestCase::Go::RESULT->to_array, $expected)) {
      return 0;
    }
    
    $TestCase::Go::RESULT = undef;
    
    return 1;
  }
  
  static method channel_cap : int () {
    
    {
      my $ch = Go->make;
      
      unless ($ch->cap == 0) {
        return 0;
      }
    }
    
    {
      my $ch = Go->make(0);
      
      unless ($ch->cap == 0) {
        return 0;
      }
    }
    
    {
      my $ch = Go->make(2);
      
      unless ($ch->cap == 2) {
        return 0;
      }
    }
    
    return 1;
  }
  
  static method channel : int () {
    
    Go->go(method : void () {
      
      my $ch = Go->make(1);
      
      Go->go([has ch : Go::Channel = $ch] method : void () {
        
        my $ch = $self->{ch};
        
        $ch->write(2);
        
        warn "Buffer 1";
      });
      
      my $ok = 0;
      
      my $value = (int)$ch->read(\$ok);
      
      warn "Buffer 1 Channel:$value";
    });
    
    Go->go(method : void () {
      
      my $ch = Go->make(2);
      
      Go->go([has ch : Go::Channel = $ch] method : void () {
        
        my $ch = $self->{ch};
        
        my $len1 = $ch->len;
        
        $ch->write(3);
        
        my $len2 = $ch->len;
        
        $ch->write(4);
        
        my $len3 = $ch->len;
        
        warn "Buffer 3";
        
        $ch->write(5);
        
        my $len4 = $ch->len;
        
        warn "Write len: $len1 $len2 $len3 $len4";
      });
      
      Go->gosched;
      
      Go->sleep(0.1);
      
      my $ok = 0;
      
      my $len1 = $ch->len;
      
      my $value1 = (int)$ch->read(\$ok);
      
      my $len2 = $ch->len;
      
      my $value2 = (int)$ch->read(\$ok);
      
      my $len3 = $ch->len;
      
      my $value3 = (int)$ch->read(\$ok);
      
      my $len4 = $ch->len;
      
      my $cap = $ch->cap;
      
      warn "Buffer 3 Channel:$value1 $value2 $value3";

      warn "Read len: $len1 $len2 $len3 $len4";
      
      warn "cap: $cap";
    });
    
    Go->go(method : void () {
      
      my $ch = Go->make(2);
      
      Go->go([has ch : Go::Channel = $ch] method : void () {
        
        my $ch = $self->{ch};
        
        my $len1 = $ch->len;
        
        $ch->write(3);
        
        my $len2 = $ch->len;
        
        $ch->write(4);
        
        my $len3 = $ch->len;
        
        warn "Buffer 3";
        
        $ch->write(5);
        
        my $len4 = $ch->len;
        
        warn "Write len: $len1 $len2 $len3 $len4";
      });
      
      my $ok = 0;
      
      my $len1 = $ch->len;
      
      my $value1 = (int)$ch->read(\$ok);
      
      my $len2 = $ch->len;
      
      my $value2 = (int)$ch->read(\$ok);
      
      my $len3 = $ch->len;
      
      my $value3 = (int)$ch->read(\$ok);
      
      my $len4 = $ch->len;
      
      my $cap = $ch->cap;
      
      warn "Buffer 3 Channel:$value1 $value2 $value3";

      warn "Read len: $len1 $len2 $len3 $len4";
      
      warn "cap: $cap";
    });
    
    Go->gosched;
    
    return 1;
  }
  
}
